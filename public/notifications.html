<!DOCTYPE html>
<html lang="tr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>MÃ¼vekkil Bildirimleri</title>
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
    <link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin>
    <link rel="stylesheet" href="./css/shared-styles.css">
    <link rel="stylesheet" href="./css/simple-loading.css">
  <style>
    body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; color:#333; display:flex; }
    .page-wrapper { flex-grow:1; display:flex; flex-direction:column; height:100vh; overflow-y:auto; background:linear-gradient(135deg,#f5f7fa 0%,#c3cfe2 100%); }
    .main-container { width: 100%; padding: 30px; padding-top: 120px; }
    .page-header { background:rgba(255,255,255,0.95); padding:30px; border-radius:20px; margin-bottom:30px; box-shadow:0 10px 30px rgba(0,0,0,0.1); }
    .page-title { font-size:2em; color:#1e3c72; margin-bottom:10px; }
    .page-subtitle { color:#666; font-size:1.1em; }
    .tasks-container { background:rgba(255,255,255,0.95); border-radius:20px; box-shadow:0 10px 30px rgba(0,0,0,0.1); overflow:hidden; }
    .tasks-table { width:100%; border-collapse:collapse; }
    .tasks-table th,.tasks-table td { padding:15px; text-align:left; border-bottom:1px solid #f0f0f0; vertical-align:top; }
    .tasks-table th { background:#f8f9fa; font-weight:600; }
    .status-badge { padding:5px 10px; border-radius:12px; color:white; font-weight:500; font-size:0.9em; }
    .status-sent{ background-color:#28a745 } .status-failed{ background-color:#dc3545 } .status-pending{ background-color:#6c757d }
    .status-badge.missing-info{ background-color:#fd7e14; color:#000 }
    .missing-info{ background-color:#ffe5c0 }
    .missing-field{ display:inline-block; background-color:#fd7e14; color:#000; padding:2px 8px; border-radius:8px; font-size:0.85em; }
    .action-btn{ background:#007bff; color:white; border:none; padding:8px 12px; border-radius:6px; cursor:pointer; margin-left:5px; transition:all .3s ease; }
    .action-btn:hover{ opacity:.9 }
    .loading{ text-align:center; padding:50px } .no-records{ text-align:center; padding:50px; color:#666 }
    #paginationContainer{ margin:12px 0 4px }
    /* Modal */
    .modal{ position:fixed; inset:0; background:rgba(0,0,0,0.6); display:none; align-items:center; justify-content:center; z-index:9999 }
    .modal-content{ background:#fff; padding:20px; width:720px; max-width:95vw; border-radius:12px; box-shadow:0 0 20px rgba(0,0,0,.2) }
    .modal-content-lg{ background:#fff; padding:20px; width:960px; max-width:95vw; border-radius:12px; box-shadow:0 0 24px rgba(0,0,0,.25); display:flex; flex-direction:column }
    .modal-header{ display:flex; align-items:center; justify-content:space-between; margin-bottom:8px }
    .modal-title{ margin:0; font-size:1.25rem } .close-modal-btn,.close{ background:transparent; border:0; font-size:28px; line-height:1; cursor:pointer }
    .modal-body{ max-height:70vh; overflow:auto } .modal-footer{ display:flex; gap:8px; justify-content:flex-end; margin-top:10px }
    .recipient-badges .badge{ display:inline-block; padding:4px 8px; border-radius:12px; font-size:12px; margin:2px 4px 0 0 }
    .badge-to{ background:#0d6efd; color:#fff } .badge-cc{ background:#17a2b8; color:#fff } .badge-empty{ background:#e9ecef; color:#555 }
    .link{ color:#0d6efd; text-decoration:underline; cursor:pointer }
    .action-btn-remind { background:#f59f00 !important; }
    .action-btn-remind:hover { background:#e67700 !important; }
  </style>

  <style>
    /* Progress Overlay */
    #progressOverlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.35);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 10000;
    }
    #progressOverlay .box {
      background: #fff;
      padding: 20px 24px;
      border-radius: 12px;
      min-width: 260px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.15);
      display: flex;
      flex-direction: column;
      gap: 12px;
      align-items: center;
    }
    .progressbar {
      width: 100%;
      height: 6px;
      background: #eee;
      border-radius: 999px;
      overflow: hidden;
    }
    .progressbar .bar {
      width: 0%;
      height: 100%;
      background: linear-gradient(90deg, #0d6efd, #20c997);
      animation: progress-indeterminate 1.4s infinite;
    }
    @keyframes progress-indeterminate {
      0% { transform: translateX(-100%); width: 40%; }
      50% { transform: translateX(30%); width: 60%; }
      100% { transform: translateX(100%); width: 40%; }
    }

    /* Tab ButonlarÄ± Stili */
    .tab-btn {
      background: none;
      border: none;
      padding: 10px 20px;
      font-size: 15px;
      font-weight: 600;
      color: #6c757d;
      cursor: pointer;
      border-bottom: 3px solid transparent;
      transition: all 0.2s ease;
    }
    .tab-btn:hover {
      color: #1e3c72;
      background-color: #f8f9fa;
      border-radius: 5px 5px 0 0;
    }
    .tab-btn.active {
      color: #1e3c72;
      border-bottom-color: #1e3c72;
    }
    .tab-btn i {
      margin-right: 8px;
    }
  </style>

</head>
<body>
  <div id="notification-container" style="position:fixed; top:20px; right:20px; z-index:9999;"></div>
  <div id="layout-placeholder"></div>

  <div class="page-wrapper">
    <main class="main-container">
      <section class="page-header">
        <h1 class="page-title">MÃ¼vekkil Bildirimleri</h1>
        <p class="page-subtitle">MÃ¼vekkillere gÃ¶nderilen bildirimleri buradan takip edebilirsiniz.</p>
      </section>

      <div class="tasks-container">
        <div class="tabs-header" style="padding: 20px 20px 0 20px; border-bottom: 1px solid #eee; display: flex; gap: 10px;">
          <button class="tab-btn active" data-tab="pending" onclick="switchTab('pending')">
            <i class="fas fa-clock"></i> Bekleyen Bildirimler
          </button>
          
          <button class="tab-btn" data-tab="reminders" onclick="switchTab('reminders')">
            <i class="fas fa-bell"></i> HatÄ±rlatmalar
          </button>
          
          <button class="tab-btn" data-tab="sent" onclick="switchTab('sent')">
            <i class="fas fa-check-circle"></i> GÃ¶nderilen Bildirimler
          </button>
        </div>
        <div id="loader" class="loading">YÃ¼kleniyor...</div>
        <div id="error" class="no-records" style="display:none;"></div>

        <div class="table-container">
          <table class="tasks-table">
            <thead>
              <tr>
                <th>Durum</th>
                <th>MÃ¼vekkil</th>
                <th>Konu</th>
                <th>BaÅŸvuru No</th>
                <th>TÃ¼r</th>
                <th>Evrak</th>
                <th>Son Tarih</th>  
                <th>Son HatÄ±rlatma</th> 
                <th>OluÅŸturma</th>
                <th>GÃ¶nderim Tarihi</th>
                <th>Ä°ÅŸlem</th>
              </tr>
            </thead>
            <tbody id="notifications-table-body"></tbody>
          </table>
          <div id="paginationContainer"></div>
        </div>
      </div>
    </main>
  </div>

  <!-- DÃ¼zenleme Modal -->
  <div id="notification-modal" class="modal">
    <div class="modal-content-lg">
      <div class="modal-header">
        <h2 class="modal-title">Bildirimi DÃ¼zenle</h2>
        <button id="close-modal" class="close-modal-btn" aria-label="Kapat">&times;</button>
      </div>
      <div class="modal-body">
        <label for="modal-subject" class="form-label">Konu</label>
        <input type="text" id="modal-subject" class="form-input" />

        <div id="mailRecipientsBlock" style="margin:12px 0;">
          <div style="margin-bottom:6px; font-weight:600;">AlÄ±cÄ±lar</div>
          <div class="d-flex" style="gap:16px; flex-wrap:wrap;">
            <div style="min-width:240px; flex:1;">
              <small class="text-muted d-block" style="margin-bottom:4px;">To</small>
              <div id="modal-to" class="recipient-badges"></div>
              <input id="modal-to-input" class="form-input" placeholder="E-posta ekle ve Enterâ€™a bas" style="margin-top:6px;">
            </div>
            <div style="min-width:240px; flex:1;">
              <small class="text-muted d-block" style="margin-bottom:4px;">CC</small>
              <div id="modal-cc" class="recipient-badges"></div>
              <input id="modal-cc-input" class="form-input" placeholder="E-posta ekle ve Enterâ€™a bas" style="margin-top:6px;">
            </div>
          </div>
        </div>

        <label for="modal-body" class="form-label">Ä°Ã§erik</label>
        <textarea id="modal-body"></textarea>
      </div>
      <div class="modal-footer">
        <button id="save-draft" class="action-btn" style="background:#6c757d">Taslak Kaydet</button>
        <button id="close-modal-btn" class="action-btn" style="background:#adb5bd">Kapat</button>
      </div>
    </div>
  </div>

  <!-- Eksik Bilgi Modal (basit) -->
  <div id="missing-info-modal" class="modal">
    <div class="modal-content">
      <button id="mi-close" class="close" aria-label="Kapat">&times;</button>
      <h3>Eksik Bilgiler</h3>
      <p>Bu bildirim ÅŸu anda <b>gÃ¶nderilmeye hazÄ±r deÄŸil</b>. LÃ¼tfen aÅŸaÄŸÄ±daki eksikleri tamamlayÄ±n.</p>
      <div style="margin:8px 0;">
        <strong>PortfÃ¶y BaÅŸvuru No:</strong>
        <span id="mi-application-no">â€”</span>
      </div>
      <div style="margin:8px 0;">
        <strong>Eksik Alanlar:</strong>
        <ul id="mi-missing-list" style="margin:6px 0;"></ul>
      </div>
      <div class="modal-footer">
        <button id="mi-edit" class="action-btn">Bildirimi DÃ¼zenle</button>
        <button id="mi-close-btn" class="action-btn" style="background:#6c757d">Kapat</button>
      </div>
    </div>
  </div>

  <!-- TinyMCE (external) -->
  <script src="https://cdn.tiny.cloud/1/uecky9tx0nvoenpj0odjyue9swj52q3sz49i62c745240d99/tinymce/6/tinymce.min.js" referrerpolicy="origin"></script>
  <script src="./js/simple-loading.js"></script>
  <!-- Main module -->
  <script type="module">
// 1. ModÃ¼lleri v10.7.1 olarak (Config dosyanÄ±zla AYNI sÃ¼rÃ¼mde) Ã§aÄŸÄ±rÄ±yoruz
    import { 
      collection, query, orderBy, onSnapshot,
      doc, getDoc, updateDoc, serverTimestamp,
      collectionGroup, where, getDocs, documentId, limit 
    } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";
    
    import { httpsCallable } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-functions.js";
    import { onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js";

    // 2. ORTAK AYAR DOSYASINI Ã‡AÄžIRIYORUZ (Oturum bilgisini paylaÅŸmak iÃ§in ÅžART!)
    import { db, auth, functions } from "./firebase-config.js"; 
    
    // DiÄŸer yerel importlarÄ±nÄ±z
    import { loadSharedLayout } from "./js/layout-loader.js";
    import Pagination from "./js/pagination.js";

    // --- PERFORMANS Ä°Ã‡Ä°N Ã–NBELLEK ---
    const dbCache = new Map(); // DokÃ¼manlarÄ± (persons/ipRecords) burada tutacaÄŸÄ±z

    // --- YENÄ° EKLENDÄ°: Merkezi Loading KontrolÃ¼ ---
    function toggleLoading(show) {
        if (window.SimpleLoadingController && typeof window.SimpleLoadingController.show === 'function') {
            if (show) window.SimpleLoadingController.show({ text: 'Bildirimler YÃ¼kleniyor...' });
            else window.SimpleLoadingController.hide();
        }
        const loader = document.getElementById("loader");
        if(loader) loader.style.display = show ? 'block' : 'none';
    }

    // GeliÅŸmiÅŸ getDocFromDb Fonksiyonu (Cache Destekli)
    async function getDocFromDb(collectionName, id) {
      if (!id) return null;
      const cacheKey = `${collectionName}/${id}`;
      
      // 1. Cache'te varsa direkt oradan dÃ¶n (Network isteÄŸi yapma)
      if (dbCache.has(cacheKey)) {
        return dbCache.get(cacheKey);
      }

      try {
        // 2. Yoksa veritabanÄ±ndan Ã§ek
        const docSnap = await getDoc(doc(db, collectionName, id));
        const data = docSnap.exists() ? docSnap.data() : null;
        
        // 3. Sonucu cache'e kaydet
        dbCache.set(cacheKey, data);
        return data;
      } catch (error) {
        console.warn(`GetDoc Error (${collectionName}/${id}):`, error);
        return null;
      }
    }

    const sendEmail = httpsCallable(functions, "sendEmailNotificationV2");

    // DOM
    const tableBody = document.getElementById("notifications-table-body");
    tableBody.replaceChildren(); 
    const loader = document.getElementById("loader");
    const errorDiv = document.getElementById("error");

    // Pagination
    let pagination;
    let notificationsData = [];
    let allNotifications = []; // TÃ¼m veriyi burada saklayacaÄŸÄ±z
    let activeTab = 'pending'; // VarsayÄ±lan sekme (pending veya sent yapabilirsiniz)
    let __isRendering = false;
    let __renderTicket = 0;
    let __rerenderPending = false;

    // ---------- Helpers: recipients ----------
    function normalize(v) {
      if (!v) return null;
      if (Array.isArray(v)) return v.filter(Boolean).map(x => String(x).trim()).filter(Boolean);
      if (typeof v === "string") return v.split(/[;,]\s*/).filter(Boolean);
      return null;
    }
    function getToCcFromNotification(n) {
      const to = normalize(n?.toList) || normalize(n?.toRecipients) || normalize(n?.recipientTo) || normalize(n?.to) || normalize(n?.recipientEmail);
      const cc = normalize(n?.ccList) || normalize(n?.ccRecipients) || normalize(n?.recipientCc) || normalize(n?.cc);
      return { toList: to || [], ccList: cc || [] };
    }

// ---------- Resolve ipRecord, supporting associatedTransactionId ----------

// Optimize edilmiÅŸ ID Ã§Ã¶zÃ¼cÃ¼ (Memoization)
async function resolveIpRecordId(notification) {
  // EÄŸer daha Ã¶nce hesapladÄ±ysak, saklanan deÄŸeri direkt dÃ¶ndÃ¼r
  if (notification._cachedIpRecordId !== undefined) {
    return notification._cachedIpRecordId;
  }

  let result = null;

  // --- Orijinal MantÄ±k ---
  if (notification.relatedIpRecordId) {
    result = notification.relatedIpRecordId;
  } else if (notification.ipRecordId) {
    result = notification.ipRecordId;
  } else if (notification.clientId) {
    try {
       // Bu sorgu cache'lenemez ama nadiren Ã§alÄ±ÅŸÄ±r (fallback)
       const ipRecordsQuery = query(
          collection(db, "ipRecords"),
          where("applicants", "array-contains", { id: notification.clientId }),
          limit(1) // Performans iÃ§in limit ekledik
        );
        const ipRecordsSnap = await getDocs(ipRecordsQuery);
        if (!ipRecordsSnap.empty) {
          result = ipRecordsSnap.docs[0].id;
        }
    } catch (e) { }
  } else if (notification.sourceDocumentId) {
    try {
      // getDocFromDb artÄ±k cache kullanÄ±yor, burasÄ± hÄ±zlanacak
      const docData = await getDocFromDb("unindexed_pdfs", notification.sourceDocumentId);
      if (docData) {
        result = docData.ipRecordId || docData.relatedIpRecordId || docData.ipRecordRefId || null;
      }
    } catch (e) { }
  }
  // -----------------------

  // Sonucu objeye kaydet (Bir sonraki Ã§aÄŸrÄ±da tekrar hesaplamasÄ±n)
  notification._cachedIpRecordId = result;
  return result;
}

async function getDocumentInfo(notification) {
  try {
    if (!notification.sourceDocumentId) return { fileName: '-', fileUrl: null };
    const docData = await getDocFromDb("unindexed_pdfs", notification.sourceDocumentId);
    return docData ? 
      { fileName: docData.fileName || '-', fileUrl: docData.fileUrl || null } :
      { fileName: '-', fileUrl: null };
  } catch (error) {
    return { fileName: '-', fileUrl: null };
  }
}
// gg/aa/yyyy formatÄ± iÃ§in kÃ¼Ã§Ã¼k yardÄ±mcÄ±
function formatDateSlashTR(input) {
  if (!input) return '-';
  let d;
  if (typeof input.toDate === 'function') d = input.toDate(); // Firestore Timestamp
  else if (input instanceof Date) d = input;
  else if (typeof input === 'number') d = new Date(input);
  else return '-';

  const dd = String(d.getDate()).padStart(2, '0');
  const mm = String(d.getMonth() + 1).padStart(2, '0');
  const yyyy = d.getFullYear();
  return `${dd}/${mm}/${yyyy}`;
}

function formatDateDDMMYYYY(d) {
  const dd = String(d.getDate()).padStart(2, '0');
  const mm = String(d.getMonth() + 1).padStart(2, '0');
  const yyyy = d.getFullYear();
  return `${dd}/${mm}/${yyyy}`;
}

// associatedTransactionId == tasks.relatedIpRecordId eÅŸleÅŸmesine gÃ¶re officialDueDate alÄ±r
async function resolveDeliveryDate(notification) {
  try {
    
    // 1. Ã–nce direkt associatedTransactionId var mÄ± kontrol et
    let txId = notification?.associatedTransactionId;
    
    // 2. Yoksa sourceDocumentId Ã¼zerinden al
    if (!txId && notification?.sourceDocumentId) {
      
      try {
        const docData = await getDocFromDb("unindexed_pdfs", notification.sourceDocumentId);
        if (docData?.associatedTransactionId) {
          txId = docData.associatedTransactionId;
        } else {
        }
      } catch (error) {
        console.error('unindexed_pdfs sorgu hatasÄ±:', error);
      }
    }
    
    if (!txId) {
      return '-';
    }

    const q = query(collection(db, 'tasks'), where('transactionId', '==', txId));
    const snap = await getDocs(q);
    
    
    if (snap.empty) {
      return '-';
    }

    // Ä°lk kaydÄ±n officialDueDate (Timestamp) alanÄ±nÄ± al
    let ts = null;
    snap.forEach(doc => { 
      if (!ts) {
        const data = doc.data();
        ts = data?.officialDueDate || null;
      }
    });
    
    if (!ts || typeof ts.toDate !== 'function') {
      return '-';
    }

    const formatted = formatDateSlashTR(ts.toDate());
    return formatted;
    
  } catch (err) {
    return '-';
  }
}

async function resolveApplicationNo(notification) {
  try {
    if (notification.applicationNo) return notification.applicationNo;

    let recordId = await resolveIpRecordId(notification);
    if (!recordId) return '-';

    // ðŸ”¥ OPTÄ°MÄ°ZASYON: YavaÅŸ aÄŸ isteÄŸi (getDoc) yerine Cache kullanan getDocFromDb kullanÄ±ldÄ±
    const recData = await getDocFromDb("ipRecords", recordId);
    if (recData) {
      return recData.applicationNumber || recData.applicationNo || recData.appNo || recData.details?.brandInfo?.applicationNo || '-';
    }

    const suitData = await getDocFromDb("suits", recordId);
    if (suitData) {
      return suitData.esasNo || suitData.caseNo || suitData.fileNo || '-';
    }

    return '-';
  } catch (error) {
    console.error("BaÅŸvuru no Ã§Ã¶zÃ¼lÃ¼rken hata:", error);
    return '-';
  }
}

async function resolveApplicantName(notification) {
  try {
    let ipRecordId = await resolveIpRecordId(notification);
    if (!ipRecordId) return '-';

    // ðŸ”¥ OPTÄ°MÄ°ZASYON: YavaÅŸ aÄŸ isteÄŸi yerine Cache kullanan getDocFromDb kullanÄ±ldÄ±
    const recData = await getDocFromDb("ipRecords", ipRecordId);
    if (!recData) return '-';
    
    const applicants = Array.isArray(recData.applicants) ? recData.applicants : [];
    if (applicants.length === 0) return '-';
    
    const names = [];
    for (const applicant of applicants) {
      if (applicant?.name) { 
        names.push(applicant.name);
        continue; 
      }
      if (applicant?.id) {
        try {
          const personData = await getDocFromDb("persons", applicant.id);
          if (personData) {
            if (personData.name) names.push(personData.name);
            else if (personData.companyName) names.push(personData.companyName);
          }
        } catch (error) {}
      }
    }
    
    return names.length ? names.join(", ") : '-';
  } catch (error) {
    return '-';
  }
}

async function resolveType(notification) {
  try {
    if (notification.type !== undefined) return String(notification.type);

    if (notification.sourceDocumentId) {
      try {
        // ðŸ”¥ AÄžA Ã‡IKMAK YERÄ°NE CACHE
        const docData = await getDocFromDb("unindexed_pdfs", notification.sourceDocumentId);
        if (docData && docData.associatedTransactionId && docData.ipRecordId) {
          const transactionDoc = await getDoc(doc(db, "ipRecords", docData.ipRecordId, "transactions", docData.associatedTransactionId));
          if (transactionDoc.exists()) {
            if (transactionDoc.data().type) return String(transactionDoc.data().type);
          }
        }
      } catch (error) { }
    }

    let ipRecordId = await resolveIpRecordId(notification);
    if (ipRecordId) {
      try {
        // Zaten Cache kullanÄ±yor
        const ipData = await getDocFromDb("ipRecords", ipRecordId);
        if (ipData && ipData.mainProcessType) return String(ipData.mainProcessType);
      } catch (error) { }
    }

    return '-';
  } catch (error) { return '-'; }
}

async function resolveDocumentInfo(notification) {
  try {
    if (notification?.supplementaryAttachment) {
      const sa = notification.supplementaryAttachment;
      return { fileName: sa.fileName || "izleme_raporu.docx", fileUrl: sa.url || sa.downloadURL || sa.fileUrl || null };
    }

    if (!notification?.sourceDocumentId) return { fileName:"-", fileUrl:null };

    // ðŸ”¥ 1) AÄžA Ã‡IKMAK YERÄ°NE CACHE'TEN DENE
    let x = await getDocFromDb("unindexed_pdfs", notification.sourceDocumentId);
    if (x) return { fileName: x.fileName || "-", fileUrl: x.fileUrl || null };

    // ðŸ”¥ 2) indexed_documents Ä°Ã‡Ä°N DE CACHE KULLAN
    const ix = await getDocFromDb("indexed_documents", notification.sourceDocumentId);
    if (ix) {
      const q = await getDocs(query(collection(db, "unindexed_pdfs"), where("evrakNo", "==", ix.etebsEvrakNo || null), limit(1)));
      if (!q.empty) {
        const ux = q.docs[0].data() || {};
        return { fileName: ux.fileName || "-", fileUrl: ux.fileUrl || null };
      }
    }

    return { fileName:"-", fileUrl:null };
  } catch (e) { return { fileName:"-", fileUrl:null }; }
}

async function getAttachmentPreviews(notification) {
  const previews = [];
  const safeName = (name, defaultName = "ek.pdf") => String(name || defaultName).replace(/[^\w.\-]+/g, "_").slice(0, 100);

  // A) Marka Ä°zleme Raporu
  if (notification?.supplementaryAttachment) {
    try {
      const sa = notification.supplementaryAttachment;
      const fileUrl = sa.url || sa.downloadURL || sa.fileUrl || null;
      const fileName = safeName(sa.fileName, "izleme_raporu.docx");
      if (fileUrl) previews.push({ fileName, fileUrl });
    } catch (e) {}
  } else if (notification?.files && Array.isArray(notification.files) && notification.files.length > 0) {
    try {
      notification.files.forEach(file => {
        const fileUrl = file.url || file.downloadUrl || file.downloadURL || file.fileUrl || null;
        if (fileUrl && !previews.some(p => p.fileUrl === fileUrl)) previews.push({ fileName: safeName(file.fileName, "ek_dosya.pdf"), fileUrl });
      });
    } catch (e) {}
  } else if (notification?.attachmentUrl) {
    try {
      const fileUrl = notification.attachmentUrl;
      const urlParts = fileUrl.split('/');
      const fileName = safeName(decodeURIComponent(urlParts[urlParts.length - 1].split('?')[0]), "izleme_raporu.docx");
      if (!previews.some(p => p.fileUrl === fileUrl)) previews.push({ fileName, fileUrl });
    } catch (e) {}
  }

  // B) Task -> EPATS (ðŸ”¥ AÄžA Ã‡IKMAK YERÄ°NE CACHE KULLANIYORUZ)
  if (notification?.associatedTaskId) {
    try {
      const tData = await getDocFromDb("tasks", notification.associatedTaskId);
      if (tData) {
        const epats = (tData.details || {}).epatsDocument || null;
        if (epats) {
          const fileUrl = epats.downloadURL || epats.downloadUrl || epats.fileUrl || null;
          if (fileUrl && !previews.some(p => p.fileUrl === fileUrl)) previews.push({ fileName: safeName(epats.name, "epats.pdf"), fileUrl });
        }
      }
    } catch (e) {}
  }

  // C) unindexed_pdfs (ðŸ”¥ AÄžA Ã‡IKMAK YERÄ°NE CACHE KULLANIYORUZ)
  if (notification?.sourceDocumentId) {
    try {
      const d = await getDocFromDb("unindexed_pdfs", notification.sourceDocumentId);
      if (d) {
        const fileUrl  = d.fileUrl || d.downloadURL || null;
        if (fileUrl && !previews.some(p => p.fileUrl === fileUrl)) previews.push({ fileName: safeName(d.fileName, "document.pdf"), fileUrl });
      } else {
        try {
          const ix = await getDocFromDb("indexed_documents", notification.sourceDocumentId);
          if (ix) {
            const qy = query(collection(db, "unindexed_pdfs"), where("evrakNo", "==", ix.etebsEvrakNo || null), where("userId", "==", ix.userId || null), limit(1));
            // Indexli dÃ¶kÃ¼manÄ± bulmak iÃ§in mecburen aÄŸa Ã§Ä±kÄ±yoruz (Ã‡ok nadir bir durum)
            const snap = await getDocs(qy);
            if (!snap.empty) {
              const ux = snap.docs[0].data() || {};
              const fileUrl  = ux.fileUrl || ux.downloadURL || null;
              if (fileUrl && !previews.some(p => p.fileUrl === fileUrl)) previews.push({ fileName: safeName(ux.fileName, "document.pdf"), fileUrl });
            }
          }
        } catch (e) {}
      }
    } catch (e) {}
  }

  return previews;
}

// ---------- Modals ----------
  function showMissingInfo(notification) {
      const modal = document.getElementById("missing-info-modal");
      const list = document.getElementById("mi-missing-list");
      list.innerHTML = "";
      const fields = Array.isArray(notification?.missingFields) ? notification.missingFields : [];
      if (fields.length) {
        for (const f of fields) {
          const li = document.createElement("li");
          li.textContent = String(f);
          list.appendChild(li);
        }
      } else {
        const li = document.createElement("li");
        li.textContent = "DetaylÄ± bilgi mevcut deÄŸil.";
        list.appendChild(li);
      }
      // application no
      resolveApplicationNo(notification).then(no => {
        document.getElementById("mi-application-no").textContent = no || "â€”";
      });
      modal.style.display = "flex";
      document.getElementById("mi-close").onclick = () => modal.style.display = "none";
      document.getElementById("mi-close-btn").onclick = () => modal.style.display = "none";
      document.getElementById("mi-edit").onclick = () => { modal.style.display = "none"; openModal(notification); };
    }

    function openModal(notification) {
      const subjectInput = document.getElementById("modal-subject");
      subjectInput.value = notification.subject || "";
      if (tinymce.get("modal-body")) tinymce.get("modal-body").remove();
      tinymce.init({
        selector: "#modal-body",
        height: 400,
        menubar: false,
        plugins: "link lists",
        toolbar: "undo redo | bold italic underline | bullist numlist | link",
        branding: false,
        language: "tr",
        setup: (editor) => {
          editor.on("init", () => {
            let html = notification.body || "";
            const bodyMatch = html.match(/<body[^>]*>([\s\S]*?)<\/body>/i);
            if (bodyMatch) html = bodyMatch[1];
            editor.setContent(html);
            document.getElementById("notification-modal").style.display = "flex";
          });
        }
      });

      // --- DEÄžÄ°ÅžÄ°KLÄ°K BAÅžLANGICI ---
      // const yerine let yapÄ±yoruz ki deÄŸiÅŸtirebilelim
      let { toList, ccList } = getToCcFromNotification(notification);

      // EÄŸer To listesi boÅŸsa ve taskOwner bilgisi varsa listeye ekle
      if ((!toList || toList.length === 0) && notification.taskOwner) {
          let ownerEmail = null;
          
          if (typeof notification.taskOwner === 'object') {
              // taskOwner objesinden email alanlarÄ±nÄ± kontrol et
              ownerEmail = notification.taskOwner.authorizedPersonEmail || notification.taskOwner.email;
          } else if (typeof notification.taskOwner === 'string' && notification.taskOwner.includes('@')) {
              // taskOwner direkt bir email stringi ise
              ownerEmail = notification.taskOwner;
          }
          
          if (ownerEmail) {
              toList = [ownerEmail];
          }
      }
      // --- DEÄžÄ°ÅžÄ°KLÄ°K BÄ°TÄ°ÅžÄ° ---

      const toEl = document.getElementById("modal-to");
      const ccEl = document.getElementById("modal-cc");
      const renderBadges = (arr, kind) => {
        if (!arr || arr.length === 0) return `<span class="badge badge-empty">â€”</span>`;
        const cls = kind === "To" ? "badge-to" : "badge-cc";
        return arr.map(e => `<span class="badge ${cls}">${e}</span>`).join(" ");
      };
      toEl.innerHTML = renderBadges(toList, "To");
      ccEl.innerHTML = renderBadges(ccList, "CC");


      // ==== Chip editor ====
      const emailRe = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;

      let currentTo = [...toList];
      let currentCc = [...ccList];

      // Ã‡Ã–ZÃœM: Elementleri klonlayarak eski event listener'lardan kurtuluyoruz
      let oldToInput = document.getElementById('modal-to-input');
      let oldCcInput = document.getElementById('modal-cc-input');

      let toInput = oldToInput.cloneNode(true);
      let ccInput = oldCcInput.cloneNode(true);

      oldToInput.parentNode.replaceChild(toInput, oldToInput);
      oldCcInput.parentNode.replaceChild(ccInput, oldCcInput);

      function renderChips() {
        const chip = (addr, cls) =>
          `<span class="badge ${cls}" data-email="${addr}">${addr} <span class="x" style="margin-left:6px;cursor:pointer;">Ã—</span></span>`;
        toEl.innerHTML = currentTo.length ? currentTo.map(a => chip(a, "badge-to")).join(" ") : `<span class="badge badge-empty">â€”</span>`;
        ccEl.innerHTML = currentCc.length ? currentCc.map(a => chip(a, "badge-cc")).join(" ") : `<span class="badge badge-empty">â€”</span>`;

        // remove handlers
        toEl.querySelectorAll('.badge .x').forEach(x => x.onclick = () => {
          const v = x.parentElement.getAttribute('data-email'); currentTo = currentTo.filter(e => e !== v); renderChips();
        });
        ccEl.querySelectorAll('.badge .x').forEach(x => x.onclick = () => {
          const v = x.parentElement.getAttribute('data-email'); currentCc = currentCc.filter(e => e !== v); renderChips();
        });
      }

      function tryAdd(list, value) {
        const v = String(value || '').trim();
        if (!v || !emailRe.test(v)) return false;
        if (!list.includes(v)) list.push(v);
        return true;
      }

      [toInput, ccInput].forEach((inp, idx) => {
        inp.addEventListener('keydown', (e) => {
          if (e.key === 'Enter' || e.key === ',' || e.key === ';') {
            e.preventDefault();
            const ok = idx === 0 ? tryAdd(currentTo, inp.value) : tryAdd(currentCc, inp.value);
            if (ok) { inp.value = ''; renderChips(); }
          }
          if (e.key === 'Backspace' && !inp.value) {
            // hÄ±zlÄ± silme: son chip
            if (idx === 0 && currentTo.length) { currentTo.pop(); renderChips(); }
            if (idx === 1 && currentCc.length) { currentCc.pop(); renderChips(); }
          }
        });
      });

      renderChips();

// Taslak kaydederken bu dizileri de kullanacaÄŸÄ±z:
      
  document.getElementById("save-draft").onclick = (() => {
    let inflight = false;
    return async () => {
      if (inflight) return;
      inflight = true;
      
      // HTML Elementlerinden verileri al
      const id = document.getElementById("save-draft").dataset.id;
      const subject = document.getElementById("modal-subject").value.trim();
      const body = tinymce.get("modal-body").getContent();
      
      try {
        __overlay.show('Taslak gÃ¼ncelleniyorâ€¦');
        
        // 1. Modal Ã¼zerindeki alÄ±cÄ±larÄ± topla
        const { toList, ccList } = collectModalRecipients();
        
        // 2. Eksik alanlarÄ± YENÄ°DEN HESAPLA
        const missingFields = [];
        const hasRecipients = (toList && toList.length > 0) || (ccList && ccList.length > 0);
        
        if (!hasRecipients) {
          missingFields.push("recipients");
        }
        // Ä°steÄŸe baÄŸlÄ±: Konu baÅŸlÄ±ÄŸÄ± zorunluysa kontrol et
        // if (!subject) missingFields.push("subject"); 

        // 3. Yeni statÃ¼yÃ¼ belirle
        // EÄŸer hala eksik alan varsa 'missing_info', yoksa 'awaiting_client_approval' (veya 'draft')
        let newStatus = missingFields.length > 0 ? 'missing_info' : 'awaiting_client_approval';

        // 4. VeritabanÄ±nÄ± gÃ¼ncelle (Status ve missingFields DAHÄ°L)
        await updateDoc(doc(db, "mail_notifications", id), {
          subject,
          body,
          isDraft: true,
          updatedAt: serverTimestamp(),
          toList,
          ccList,
          // -- Eklenen Kritik KÄ±sÄ±m --
          status: newStatus,
          missingFields: missingFields
        });

        alert("Taslak baÅŸarÄ±yla gÃ¼ncellendi ve durumu dÃ¼zeltildi!");
        document.getElementById("notification-modal").style.display = "none";
        
      } catch (err) {
        console.error("Kaydetme hatasÄ±:", err);
        alert("Taslak kaydedilemedi: " + err.message);
      } finally {
        __overlay.hide();
        inflight = false;
      }
    };
  })();


      // ==== /Chip editor ====
      (async () => {
      const modalBodyEl = document.querySelector('#notification-modal .modal-body');
      // "Ä°Ã§erik" etiketini bulup onun Ã–NÃœNE yerleÅŸtireceÄŸiz
      const contentLabel = modalBodyEl.querySelector('label[for="modal-body"]');

      // Tek seferlik ipucu alanÄ± oluÅŸtur
      let hintEl = document.getElementById('attachment-hint');
      if (!hintEl) {
        hintEl = document.createElement('div');
        hintEl.id = 'attachment-hint';
        hintEl.style.margin = '8px 0 12px';
        hintEl.style.fontSize = '12px';
        hintEl.style.color = '#6c757d';
        // Ä°Ã§erik etiketinden Ã¶nce gÃ¶ster
        modalBodyEl.insertBefore(hintEl, contentLabel);
      }

      
      // Belge bilgisini getir ve doldur (Ã§ok-kaynaklÄ±)
      const previews = await getAttachmentPreviews(notification);
      if (Array.isArray(previews) && previews.length) {
        const links = previews.map(p => p.fileUrl
          ? `<a href="${p.fileUrl}" target="_blank" rel="noopener">${p.fileName}</a>`
          : `${p.fileName || '-'}`
        ).join(" | ");
        hintEl.innerHTML = `Ek KaynaÄŸÄ±: ${links}`;
      } else {
        hintEl.innerHTML = `Ek KaynaÄŸÄ±: -`;
      }
    })();

document.getElementById("save-draft").dataset.id = notification.id;
      ["close-modal", "close-modal-btn"].forEach(id => {
        const el = document.getElementById(id);
        if (!el) return;
        el.onclick = () => {
          document.getElementById("notification-modal").style.display = "none";
          document.getElementById("modal-subject").value = "";
          if (tinymce.get("modal-body")) tinymce.get("modal-body").remove();
        };
      });
    }
  
function collectModalRecipients() {
  const emailRe = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;

  const pillEmails = (sel) =>
    Array.from(document.querySelectorAll(sel))
      .map(el => el.getAttribute('data-email'))
      .filter(Boolean);

  const toChips = pillEmails('#modal-to .badge[data-email]');
  const ccChips = pillEmails('#modal-cc .badge[data-email]');

  const toInput = document.getElementById('modal-to-input');
  const ccInput = document.getElementById('modal-cc-input');

  const maybe = (v) => {
    const s = String(v || '').trim();
    return s && emailRe.test(s) ? [s] : [];
  };

  // Enterâ€™a basÄ±lmadan kalan yazÄ±yÄ± da dahil et
  const extraTo = maybe(toInput?.value);
  const extraCc = maybe(ccInput?.value);

  const uniq = (arr) => Array.from(new Set(arr));

  return {
    toList: uniq([ ...toChips, ...extraTo ]),
    ccList: uniq([ ...ccChips, ...extraCc ]),
  };
}

window.switchTab = async function(tabName) {
      activeTab = tabName;
      
      document.querySelectorAll('.tab-btn').forEach(btn => {
        if (btn.dataset.tab === tabName) btn.classList.add('active');
        else btn.classList.remove('active');
      });

      await applyTabFilter();
    };

async function applyTabFilter() {
      toggleLoading(true);
      tableBody.innerHTML = "";

      try {
        if (activeTab === 'pending') {
          // 1. BEKLEYENLER: StatÃ¼sÃ¼ 'sent' olmayan her ÅŸey
          notificationsData = allNotifications.filter(n => n.status !== 'sent');
        } else {
          // 2. GÃ–NDERÄ°LENLER VE HATIRLATMALAR Ä°Ã‡Ä°N TASK KONTROLÃœ
          const sentNotifications = allNotifications.filter(n => n.status === 'sent');
          
          // Mail iÃ§indeki 'dependentTaskId' alanlarÄ±nÄ± topluyoruz
          const taskIds = [...new Set(sentNotifications.map(n => n.dependentTaskId).filter(id => id))];
          
          const taskStatusMap = {};
          // Task statÃ¼lerini topluca (paralel) Firestore'dan Ã§ekiyoruz
          await Promise.all(taskIds.map(async (id) => {
            const taskData = await getDocFromDb("tasks", id);
            if (taskData) taskStatusMap[id] = taskData.status;
          }));

          if (activeTab === 'reminders') {
            // HATIRLATMALAR: VeritabanÄ±ndaki teknik statÃ¼ "awaiting_client_approval"
            notificationsData = sentNotifications.filter(n => {
              const tId = n.dependentTaskId;
              const taskStatus = taskStatusMap[tId];
              // ðŸ”¥ Metni "awaiting_client_approval" olarak gÃ¼ncelledik:
              return tId && taskStatus === "awaiting_client_approval";
            });
          } else {
            // GÃ–NDERÄ°LENLER: StatÃ¼ "awaiting_client_approval" DEÄžÄ°LSE veya iÅŸ yoksa
            notificationsData = sentNotifications.filter(n => {
              const tId = n.dependentTaskId;
              const taskStatus = taskStatusMap[tId];
              return !tId || taskStatus !== "awaiting_client_approval";
            });
          }
        }

        // Tabloyu ve Pagination'Ä± gÃ¼ncelle
        const emptyMsgs = {
          'pending': 'Bekleyen bildirim bulunamadÄ±.',
          'reminders': 'HatÄ±rlatÄ±lacak (onay bekleyen) bildirim bulunamadÄ±.',
          'sent': 'TamamlanmÄ±ÅŸ gÃ¶nderim bulunamadÄ±.'
        };

        if (pagination) {
          pagination.update(notificationsData.length);
          pagination.goToPage(1);
        }

        if (notificationsData.length === 0) {
          tableBody.innerHTML = `<tr><td colspan="11" class="no-records">${emptyMsgs[activeTab]}</td></tr>`;
        } else {
          await renderCurrentPage();
        }
      } catch (err) {
        console.error("Filtreleme hatasÄ±:", err);
        tableBody.innerHTML = `<tr><td colspan="11" class="no-records">Veriler iÅŸlenirken hata oluÅŸtu.</td></tr>`;
      } finally {
        toggleLoading(false);
      }
    }

    // ---------- Firestore listener ----------
    let notificationsUnsub = null;

function startNotificationListener() {
      toggleLoading(true);
      const qy = query(collection(db, "mail_notifications"), orderBy("createdAt", "desc"));
      
      notificationsUnsub && notificationsUnsub();
      
      notificationsUnsub = onSnapshot(qy, async (snapshot) => {
        toggleLoading(false);
        
        if (snapshot.empty) {
          allNotifications = [];
          notificationsData = [];
          await applyTabFilter();
          return;
        }

        allNotifications = snapshot.docs.map(d => ({ id: d.id, ...d.data() }));

        if (!pagination) {
          pagination = new Pagination({
            containerId: "paginationContainer",
            itemsPerPage: 20,
            maxVisiblePages: 7,
            onPageChange: () => renderCurrentPage(),
            showFirstLast: true,
            showPrevNext: true,
            showPageInfo: true,
            showItemsPerPageSelector: true
          });
        }

        await applyTabFilter();

      }, (error) => {
        loader.style.display = "none";
        errorDiv.style.display = "block";
        errorDiv.textContent = "Bildirimler yÃ¼klenirken bir hata oluÅŸtu.";
        console.error("Firestore Listener HatasÄ±:", error);
      });
    }

  onAuthStateChanged(auth, (user) => {
      if (user) {
        loadSharedLayout({ activeMenuLink: "notifications.html" });
        startNotificationListener();
      } else {
        loader.textContent = "Bu sayfayÄ± gÃ¶rmek iÃ§in giriÅŸ yapmalÄ±sÄ±nÄ±z.";
      }
    });
async function getApplicantName(notification) {
  try {
    // HÄ±zlÄ± kontroller
    if (notification.applicant?.name) return notification.applicant.name;
    if (notification.applicantName) return notification.applicantName;

    // clientId varsa direkt kullan
    if (notification.clientId) {
      const clientData = await getDocFromDb("persons", notification.clientId);
      if (clientData) return clientData.name || clientData.companyName || '-';
    }

    // ipRecordId Ã¼zerinden
    if (notification.ipRecordId) {
      const ipData = await getDocFromDb("ipRecords", notification.ipRecordId);
      if (ipData?.applicants?.length > 0) {
        const firstApplicant = ipData.applicants[0];
        if (firstApplicant.name) return firstApplicant.name;
        if (firstApplicant.id) {
          const personData = await getDocFromDb("persons", firstApplicant.id);
          if (personData) return personData.name || personData.companyName || '-';
        }
      }
    }

    // sourceDocumentId Ã¼zerinden
    if (notification.sourceDocumentId) {
      const docData = await getDocFromDb("unindexed_pdfs", notification.sourceDocumentId);
      if (docData?.ipRecordId) {
        const ipData = await getDocFromDb("ipRecords", docData.ipRecordId);
        if (ipData?.applicants?.length > 0) {
          const firstApplicant = ipData.applicants[0];
          if (firstApplicant.name) return firstApplicant.name;
          if (firstApplicant.id) {
            const personData = await getDocFromDb("persons", firstApplicant.id);
            if (personData) return personData.name || personData.companyName || '-';
          }
        }
      }
    }

    return '-';
  } catch (error) {
    console.error('getApplicantName error:', error);
    return '-';
  }
}

async function renderCurrentPage() {
  if (!pagination) return;

  // Ã‡akÄ±ÅŸma Ã¶nleyici (HÄ±zlÄ± sayfa geÃ§iÅŸleri iÃ§in)
  if (__isRendering) { __rerenderPending = true; return; }
  __isRendering = true;
  const myTicket = ++__renderTicket;

  const slice = pagination.getCurrentPageData(notificationsData || []);

  if (!slice.length) {
    tableBody.innerHTML = '<tr><td colspan="11" class="no-records">GÃ¶sterilecek bildirim bulunamadÄ±.</td></tr>';
    __isRendering = false;
    if (__rerenderPending) { __rerenderPending = false; renderCurrentPage(); }
    return;
  }

  // ðŸ”¥ YENÄ° EKLENEN KOD: Ekranda gÃ¶rÃ¼nen 20 kaydÄ±n tÃ¼m ihtiyaÃ§larÄ±nÄ± (Marka, KiÅŸi, Dosya) TEK SEFERDE Ã§ekip Ã¶nbelleÄŸe (dbCache) atÄ±yoruz.
  const ipRecordIds = new Set();
  const personIds = new Set();
  const taskIds = new Set();
  const pdfIds = new Set();

  for (const notif of slice) {
      if (notif.ipRecordId) ipRecordIds.add(notif.ipRecordId);
      if (notif.relatedIpRecordId) ipRecordIds.add(notif.relatedIpRecordId);
      if (notif.clientId) personIds.add(notif.clientId);
      if (typeof notif.taskOwner === 'string') personIds.add(notif.taskOwner);
      if (Array.isArray(notif.taskOwner) && typeof notif.taskOwner[0] === 'string') personIds.add(notif.taskOwner[0]);
      if (notif.dependentTaskId) taskIds.add(notif.dependentTaskId);
      if (notif.associatedTaskId) taskIds.add(notif.associatedTaskId);
      if (notif.sourceDocumentId) pdfIds.add(notif.sourceDocumentId);
  }

  // 10'arlÄ± gruplar halinde Firestore "in" sorgusu atma fonksiyonu
  async function prefetchChunks(collectionName, idsSet) {
      const ids = Array.from(idsSet).filter(id => id && !dbCache.has(`${collectionName}/${id}`));
      if (ids.length === 0) return;
      
      const chunks = [];
      for (let i = 0; i < ids.length; i += 10) chunks.push(ids.slice(i, i + 10));

      await Promise.all(chunks.map(async (chunk) => {
          try {
              const q = query(collection(db, collectionName), where(documentId(), "in", chunk));
              const snap = await getDocs(q);
              snap.forEach(doc => { dbCache.set(`${collectionName}/${doc.id}`, doc.data()); });
          } catch (e) { console.warn(`Prefetch hatasÄ± (${collectionName}):`, e); }
      }));
  }

  // Arka planda tÃ¼m verileri paralel (aynÄ± anda) Ã§ek
  await Promise.all([
      prefetchChunks("ipRecords", ipRecordIds),
      prefetchChunks("persons", personIds),
      prefetchChunks("tasks", taskIds),
      prefetchChunks("unindexed_pdfs", pdfIds)
  ]);
  // ðŸ”¥ YENÄ° EKLENEN KODUN SONU

  // TÃ¼m satÄ±rlarÄ± paralel olarak iÅŸle (AÅŸaÄŸÄ±daki kÄ±sÄ±mlar sizin kodunuzla tamamen AYNIDIR)
  const rows = await Promise.all(slice.map(async (notification) => {
    const tr = document.createElement('tr');

    // --- 1. STATÃœ YÃ–NETÄ°MÄ° ---
    const statusMap = {
      'sent': 'GÃ¶nderildi',
      'failed': 'Hata OluÅŸtu',
      'pending': 'GÃ¶nderim SÄ±rasÄ±nda',
      'missing_info': 'Eksik Bilgi',
      'awaiting_client_approval': 'Onay Bekliyor', // Taslak yerine daha aÃ§Ä±klayÄ±cÄ±
      'draft': 'Taslak',
      'client_approval_closed': 'OnaylandÄ± (KapatÄ±ldÄ±)',
      'client_no_response_closed': 'Cevap AlÄ±namadÄ±',
      'evaluation_pending': 'DeÄŸerlendirme Bekliyor' // --- YENÄ° EKLENDÄ° ---
    };

    let statusClass = 'status-pending'; // VarsayÄ±lan gri
    if (notification.status === 'sent') statusClass = 'status-sent';
    else if (notification.status === 'failed') statusClass = 'status-failed';
    else if (notification.status === 'missing_info') statusClass = 'missing-info';
    else if (notification.status === 'awaiting_client_approval') statusClass = 'status-pending';
    else if (notification.status === 'evaluation_pending') statusClass = 'status-pending'; // DeÄŸerlendirme iÃ§in gri renk

    const statusText = statusMap[notification.status] || notification.status || '-';

    // --- 2. KONU ---
    const subjectCell = notification.subject
      ? notification.subject
      : '<span class="missing-field">Konu Eksik</span>';

    // --- 3. ASENKRON VERÄ° Ã‡Ã–ZÃœMLEME ---
    const [
      clientDisplay,      // MÃ¼vekkil SÃ¼tunu
      applicationNoText,  // BaÅŸvuru No
      typeText,           // TÃ¼r
      docInfo,            // Ekler
      deliveryDateText    // Son Tarih
    ] = await Promise.all([
      

    // A) MÃœVEKKÄ°L SÃœTUNU MANTIÄžI
      (async () => {
        // 1. Ã–NCELÄ°K: Task Owner (GÃ¶rev Sahibi)
        if (notification.taskOwner) {
            
            // SENARYO 1: taskOwner bir String (ID) ise - Ã–rn: "64ed6f..."
            if (typeof notification.taskOwner === 'string') {
                try {
                    const personData = await getDocFromDb("persons", notification.taskOwner);
                    if (personData) {
                        return personData.name || personData.companyName || notification.taskOwner;
                    }
                } catch (e) {
                    console.warn("MÃ¼vekkil ID'si Ã§Ã¶zÃ¼lÃ¼rken hata:", e);
                }
                return notification.taskOwner;
            }

            // SENARYO 2: taskOwner bir Dizi (Array) ise - Ã–rn: ["64ed6f..."]
            if (Array.isArray(notification.taskOwner) && notification.taskOwner.length > 0) {
                const firstVal = notification.taskOwner[0];
                
                if (typeof firstVal === 'string') {
                     try {
                        const personData = await getDocFromDb("persons", firstVal);
                        if (personData) {
                            return personData.name || personData.companyName || firstVal;
                        }
                    } catch (e) {}
                    return firstVal;
                }
                
                if (typeof firstVal === 'object' && firstVal.name) return firstVal.name;
            }

            // SENARYO 3: taskOwner eski tip bir Obje ise
            if (typeof notification.taskOwner === 'object' && notification.taskOwner.name) {
                return notification.taskOwner.name;
            }
        }
        
        // 2. Yedek: applicantName
        if (notification.applicantName) return notification.applicantName;
        
        // 3. VeritabanÄ±ndan (ipRecords Ã¼zerinden) bulmaya Ã§alÄ±ÅŸ
        try { 
            const resolved = await resolveApplicantName(notification); 
            if (resolved && resolved !== '-') return resolved;
        } catch (e) {}

        // 4. Son Ã‡are: To listesindeki ilk alÄ±cÄ±
        const { toList } = getToCcFromNotification(notification);
        if (toList && toList.length > 0) return toList[0];
        
        return '-';
      })(),
      
      // B) BAÅžVURU NO
      (async () => {
        if (notification.applicationNo) return notification.applicationNo;
        try { return await resolveApplicationNo(notification); } catch { return '-'; }
      })(),

      // C) TÃœR (Marka, Patent vb.)
      (async () => {
        try {
          let rawType = '';
          if (notification.type) rawType = String(notification.type);
          else if (notification.notificationType) rawType = String(notification.notificationType);
          else rawType = await resolveType(notification);

          const map = {
            trademark: 'Marka', marka: 'Marka',
            patent: 'Patent',
            design: 'TasarÄ±m', tasarim: 'TasarÄ±m',
            litigation: 'Dava', dava: 'Dava',
            objection: 'Ä°tiraz', itiraz: 'Ä°tiraz'
          };
          return map[rawType.toLowerCase?.() || ''] || rawType || '-';
        } catch { return '-'; }
      })(),

      // D) EKLER (Dosya Linkleri)
      getAttachmentPreviews(notification),

      // E) SON TARÄ°H
      (async () => {
        try { return await resolveDeliveryDate(notification); } catch { return '-'; }
      })()
    ]);

    // --- 4. FORMATLAMA ---
    const fileCellHtml = (Array.isArray(docInfo) && docInfo.length)
      ? docInfo.map(p => p.fileUrl
          ? `<a class="link" href="${p.fileUrl}" target="_blank" rel="noopener">${p.fileName}</a>`
          : `${p.fileName || '-'}`
        ).join("<br>")
      : '-';

    const sentAtText = (notification.sentAt && typeof notification.sentAt.toDate === 'function')
      ? notification.sentAt.toDate().toLocaleString('tr-TR') : '-';

    const lastReminderText = (notification.lastReminderAt && typeof notification.lastReminderAt.toDate === 'function')
      ? notification.lastReminderAt.toDate().toLocaleString('tr-TR') : '-';

    const createdAtText = (notification.createdAt && typeof notification.createdAt.toDate === 'function')
      ? notification.createdAt.toDate().toLocaleString('tr-TR') 
      : (notification.createdAt ? new Date(notification.createdAt).toLocaleString('tr-TR') : '-');

    // --- 5. HTML OLUÅžTURMA ---
    tr.innerHTML = `
      <td><span class="status-badge ${statusClass}">${statusText}</span></td>
      <td>${clientDisplay || '-'}</td>
      <td>${subjectCell}</td>
      <td>${applicationNoText || '-'}</td>
      <td>${typeText || '-'}</td>
      <td>${fileCellHtml}</td>
      <td>${deliveryDateText || '-'}</td>
      <td>${lastReminderText}</td>
      <td>${createdAtText}</td>
      <td>${sentAtText}</td>
      <td class="actions-cell"></td>
    `;

    // --- 6. BUTONLAR ---
    const actionCell = tr.querySelector('.actions-cell');
    
    // DeÄŸerlendirme Bekliyor durumunda butonlar pasif mi?
    const isEvaluationPending = (notification.status === 'evaluation_pending');

    // DÃ¼zenle Butonu (Her zaman gÃ¶rÃ¼nÃ¼r ama pasif olabilir)
    const editButton = document.createElement('button');
    editButton.className = 'action-btn';
    editButton.textContent = 'DÃ¼zenle';
    editButton.dataset.id = notification.id;
    
    if (isEvaluationPending) {
        editButton.disabled = true;
        editButton.style.opacity = '0.5';
        editButton.style.cursor = 'not-allowed';
        editButton.title = "DeÄŸerlendirme tamamlanmadan dÃ¼zenlenemez.";
    } else {
        editButton.addEventListener('click', () => openModal(notification));
    }
    actionCell.appendChild(editButton);

    // Duruma GÃ¶re DiÄŸer Butonlar
    if (notification.status === 'missing_info') {
      const missingBtn = document.createElement('button');
      missingBtn.className = 'action-btn';
      missingBtn.textContent = 'Eksik Bilgileri GÃ¶ster';
      missingBtn.dataset.id = notification.id;
      missingBtn.addEventListener('click', () => showMissingInfo(notification));
      actionCell.appendChild(missingBtn);
    } else if (notification.status === 'sent') {
      const remindBtn = document.createElement('button');
      remindBtn.className = 'action-btn action-btn-remind';
      remindBtn.textContent = 'HatÄ±rlat';
      remindBtn.dataset.id = notification.id;
      remindBtn.addEventListener('click', (e) => sendReminderWithUI(e, notification));
      actionCell.appendChild(remindBtn);
    } else {
      const sendBtn = document.createElement('button');
      sendBtn.className = 'action-btn';
      // Hata varsa "Tekrar GÃ¶nder", yoksa "GÃ¶nder"
      sendBtn.textContent = (notification.status === 'failed') ? 'Tekrar GÃ¶nder' : 'GÃ¶nder';
      sendBtn.dataset.id = notification.id;
      
      if (isEvaluationPending) {
          sendBtn.disabled = true;
          sendBtn.style.opacity = '0.5';
          sendBtn.style.cursor = 'not-allowed';
          sendBtn.title = "DeÄŸerlendirme tamamlanmadan gÃ¶nderilemez.";
      } else {
          sendBtn.addEventListener('click', (e) => sendNotificationWithUI(e, notification));
      }
      actionCell.appendChild(sendBtn);
    }

    return tr;
  }));

  // Render sÄ±rasÄ±nda yeni bir istek geldiyse iÅŸlemi iptal et
  if (myTicket !== __renderTicket) {
    __isRendering = false;
    if (__rerenderPending) { __rerenderPending = false; renderCurrentPage(); }
    return;
  }

  // DOM'u gÃ¼ncelle
  const frag = document.createDocumentFragment();
  rows.forEach(tr => frag.appendChild(tr));
  tableBody.replaceChildren(frag);

  __isRendering = false;
  if (__rerenderPending) { __rerenderPending = false; renderCurrentPage(); }
}

// ---------- Global exposures ----------
    try { globalThis.openModal = openModal; } catch (e) {}
    try { globalThis.showMissingInfo = showMissingInfo; } catch (e) {}
    try { globalThis.getToCcFromNotification = getToCcFromNotification; } catch (e) {}
    try { globalThis.sendEmail = sendEmail; } catch (e) {}
    if (typeof globalThis.sendNotification !== "function") {
      globalThis.sendNotification = async function(notification) {
        try {
          await sendEmail({ notificationId: notification.id });
        } catch (e) {
          console.error("sendNotification fallback error:", e);
          alert("GÃ¶nderim sÄ±rasÄ±nda bir hata oluÅŸtu.");
        }
      };
    }

if (typeof globalThis.sendReminder !== "function") {
  globalThis.sendReminder = async function(notification) {
    try {
      const user = auth.currentUser;
      if (!user) { alert("GiriÅŸ yapmalÄ±sÄ±nÄ±z."); return; }

      // EÄŸer modal aÃ§Ä±kken dÃ¼zenlendi ise o anki baÅŸlÄ±k/iÃ§eriÄŸi topla
      let overrideSubject = null;
      let overrideBody = null;
      const modalEl = document.getElementById('notification-modal');
      const isModalOpen = modalEl && getComputedStyle(modalEl).display !== 'none';

      if (isModalOpen) {
        overrideSubject = document.getElementById('modal-subject')?.value?.trim() || null;
        // TinyMCE varsa iÃ§eriÄŸi al
        overrideBody = (window.tinymce && tinymce.get('modal-body'))
          ? (tinymce.get('modal-body').getContent() || '').trim()
          : (document.getElementById('modal-body')?.value || '').trim();
        if (!overrideBody) overrideBody = null;
      }

      // (Opsiyonel) taslak meta gÃ¼ncelle
      await updateDoc(doc(db, "mail_notifications", notification.id), {
        updatedAt: serverTimestamp()
      });

      // Mode: 'reminder' + overrideâ€™lar
      await sendEmail({
        notificationId: notification.id,
        userEmail: user.email,
        mode: 'reminder',
        overrideSubject,
        overrideBody
      });

      alert("HatÄ±rlatma e-postasÄ± gÃ¶nderim sÄ±rasÄ±na alÄ±ndÄ±.");
    } catch (e) {
      console.error("sendReminder error:", e);
      alert("HatÄ±rlatma gÃ¶nderilemedi.");
    }
  };
}

// resolveDocumentInfo fonksiyonunu global yap
window.getAttachmentPreviews = getAttachmentPreviews;
globalThis.getAttachmentPreviews = getAttachmentPreviews;

// Debug iÃ§in global notificationsData eriÅŸimi
Object.defineProperty(window, 'debugNotificationsData', {
  get: () => notificationsData,
  enumerable: true
});
const __sendBtn = document.getElementById("send-notification");
if (__sendBtn) {
  __sendBtn.addEventListener("click", async () => {
    const id = __sendBtn.dataset.id; // aynÄ± elemana ikinci kez DOM'dan bakmana gerek yok
    const subject = document.getElementById("modal-subject").value.trim();
    const body = tinymce.get("modal-body").getContent();
    const user = auth.currentUser;

    if (!user) { alert("GiriÅŸ yapmalÄ±sÄ±nÄ±z."); return; }
    if (!confirm("Bu e-postayÄ± gÃ¶ndermek istediÄŸinize emin misiniz?")) return;

    
    // DEBUG: Ek kontrolÃ¼ (Ã§ok-kaynaklÄ±)
    const notification = notificationsData.find(n => n.id === id);
    try {
      const previews = await getAttachmentPreviews(notification);
      if (!Array.isArray(previews) || previews.length === 0) {
        console.warn('âš ï¸ [DEBUG] Ek Ã¶nizlemesi bulunamadÄ±; backend ek Ã¼retemeyebilir.');
      }
    } catch (err) {
      console.error('âŒ [DEBUG] getAttachmentPreviews error:', err);
    }

try {
      // ðŸ”´ En Ã¶nemlisi: Modalden TO/CCâ€™yi topla ve DOKÃœMANA YAZ
      const { toList, ccList } = collectModalRecipients();

      await updateDoc(doc(db, "mail_notifications", id), {
        subject,
        body,
        isDraft: false,
        status: "pending",
        missingFields: [],
        updatedAt: serverTimestamp(),
        sentBy: (user.email || user.uid),
        // AlÄ±cÄ±lar:
        toList,
        ccList,
        recipientTo: toList,
        recipientCc: ccList,
        toRecipients: toList,
        ccRecipients: ccList
      });

      // RAMâ€™i de gÃ¼ncel tut (modal tekrar aÃ§Ä±ldÄ±ÄŸÄ±nda doÄŸru gÃ¶rÃ¼nsÃ¼n)
      const notif = notificationsData.find(n => n.id === id);
      if (notif) {
        notif.subject = subject;
        notif.body = body;
        notif.toList = toList;
        notif.ccList = ccList;
        notif.isDraft = false;
        notif.status = "pending";
      }

      // ArtÄ±k dokÃ¼manda en gÃ¼ncel TO/CC var â†’ backend buradan okuyacak
      await sendEmail({ notificationId: id, userEmail: user.email });

      alert("E-posta gÃ¶nderim sÄ±rasÄ±na alÄ±ndÄ±!");
      document.getElementById("notification-modal").style.display = "none";
    } catch (err) {
      console.error('âŒ [DEBUG] GÃ¶nderim hatasÄ±:', err);
      alert("GÃ¶nderim sÄ±rasÄ±nda bir hata oluÅŸtu.");
    }
  });
}
  </script>
  <div id="progressOverlay" role="status" aria-live="polite">
    <div class="box">
      <div id="progressMessage">Ä°ÅŸlem yapÄ±lÄ±yorâ€¦</div>
      <div class="progressbar"><div class="bar"></div></div>
    </div>
  </div>
<script>
  // Progress overlay helpers (self-contained)
  const __overlay = {
    el: null, msgEl: null,
    init() {
      this.el = document.getElementById('progressOverlay');
      this.msgEl = document.getElementById('progressMessage');
    },
    show(message='Ä°ÅŸlem yapÄ±lÄ±yorâ€¦') {
      if (!this.el) this.init();
      if (this.msgEl) this.msgEl.textContent = message;
      if (this.el) this.el.style.display = 'flex';
      document.querySelectorAll('.actions-cell .action-btn').forEach(b => b.disabled = true);
    },
    hide() {
      if (!this.el) this.init();
      if (this.el) this.el.style.display = 'none';
      document.querySelectorAll('.actions-cell .action-btn').forEach(b => b.disabled = false);
    }
  };

  async function sendReminderWithUI(e, notification) {
    const btn = e && e.currentTarget ? e.currentTarget : null;
    try {
      if (btn) btn.disabled = true;
      __overlay.show('HatÄ±rlatma gÃ¶nderiliyorâ€¦');
      await sendReminder(notification);
    } finally {
      __overlay.hide();
      if (btn) btn.disabled = false;
    }
  }

// --- YENÄ° GÃ–NDERÄ°M FONKSÄ°YONU (UI MesajÄ± DÃ¼zeltildi) ---
  async function sendNotificationWithUI(e, notification) {
      const btn = e && e.currentTarget ? e.currentTarget : null;

      // Validasyon: To listesini kontrol et
      const { toList } = getToCcFromNotification(notification);
      
      if (!toList || toList.length === 0) {
          alert("HATA: 'Kime' (To) alanÄ± boÅŸ. Sadece CC ile veya alÄ±cÄ±sÄ±z gÃ¶nderim yapÄ±lamaz.\n\nLÃ¼tfen 'DÃ¼zenle' butonuna basarak en az bir alÄ±cÄ± ekleyin.");
          return; 
      }

      try {
        if (btn) btn.disabled = true;
        
        // --- DÃœZELTME: DoÄŸru mesajÄ± gÃ¶ster ---
        // EÄŸer global __overlay objesi varsa onu kullan, yoksa manuel gÃ¶ster
        if (typeof __overlay !== 'undefined' && __overlay.show) {
            __overlay.show('E-posta gÃ¶nderiliyor...');
        } else {
            const overlay = document.getElementById('progressOverlay');
            const msg = document.getElementById('progressMessage');
            if (msg) msg.textContent = 'E-posta gÃ¶nderiliyor...';
            if (overlay) overlay.style.display = 'flex';
        }
        
        await sendEmail({ notificationId: notification.id });
        alert("E-posta baÅŸarÄ±yla gÃ¶nderildi.");
        
      } catch (err) {
          console.error(err);
          alert("GÃ¶nderim sÄ±rasÄ±nda hata oluÅŸtu: " + (err.message || err));
      } finally {
        // Overlay kapat
        if (typeof __overlay !== 'undefined' && __overlay.hide) {
            __overlay.hide();
        } else {
            const overlay = document.getElementById('progressOverlay');
            if (overlay) overlay.style.display = 'none';
        }
        
        if (btn) btn.disabled = false;
      }
  }
  
  window.sendNotificationWithUI = sendNotificationWithUI;
</script>

</body>
</html>
